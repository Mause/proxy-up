/* tslint:disable */
/* eslint-disable */
/**
 * Up API
 * The Up API gives you programmatic access to your balances and transaction data. You can request past transactions or set up webhooks to receive real-time events when new transactions hit your account. It’s new, it’s exciting and it’s just the beginning.
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 * Provides information about an Up bank account.
 * @export
 * @interface AccountResource
 */
export interface AccountResource {
  /**
   * The type of this resource: `accounts`
   * @type {string}
   * @memberof AccountResource
   */
  type: string;
  /**
   * The unique identifier for this account.
   * @type {string}
   * @memberof AccountResource
   */
  id: string;
  /**
   *
   * @type {AccountResourceAttributes}
   * @memberof AccountResource
   */
  attributes: AccountResourceAttributes;
  /**
   *
   * @type {AccountResourceRelationships}
   * @memberof AccountResource
   */
  relationships: AccountResourceRelationships;
  /**
   *
   * @type {AccountResourceLinks}
   * @memberof AccountResource
   */
  links?: AccountResourceLinks;
}
/**
 *
 * @export
 * @interface AccountResourceAttributes
 */
export interface AccountResourceAttributes {
  /**
   * The name associated with the account in the Up application.
   * @type {string}
   * @memberof AccountResourceAttributes
   */
  displayName: string;
  /**
   * The bank account type of this account.
   * @type {AccountTypeEnum}
   * @memberof AccountResourceAttributes
   */
  accountType: AccountTypeEnum;
  /**
   * The available balance of the account, taking into account any amounts that are currently on hold.
   * @type {MoneyObject}
   * @memberof AccountResourceAttributes
   */
  balance: MoneyObject;
  /**
   * The date-time at which this account was first opened.
   * @type {string}
   * @memberof AccountResourceAttributes
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface AccountResourceLinks
 */
export interface AccountResourceLinks {
  /**
   * The canonical link to this resource within the API.
   * @type {string}
   * @memberof AccountResourceLinks
   */
  self: string;
}
/**
 *
 * @export
 * @interface AccountResourceRelationships
 */
export interface AccountResourceRelationships {
  /**
   *
   * @type {AccountResourceRelationshipsTransactions}
   * @memberof AccountResourceRelationships
   */
  transactions: AccountResourceRelationshipsTransactions;
}
/**
 *
 * @export
 * @interface AccountResourceRelationshipsTransactions
 */
export interface AccountResourceRelationshipsTransactions {
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof AccountResourceRelationshipsTransactions
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface AccountResourceRelationshipsTransactionsLinks
 */
export interface AccountResourceRelationshipsTransactionsLinks {
  /**
   * The link to retrieve the related resource(s) in this relationship.
   * @type {string}
   * @memberof AccountResourceRelationshipsTransactionsLinks
   */
  related: string;
}
/**
 * Specifies the type of bank account. Currently returned values are `SAVER` and `TRANSACTIONAL`.
 * @export
 * @enum {string}
 */

export enum AccountTypeEnum {
  Saver = "SAVER",
  Transactional = "TRANSACTIONAL",
}

/**
 * Provides information about an instant reimbursement in the form of cashback.
 * @export
 * @interface CashbackObject
 */
export interface CashbackObject {
  /**
   * A brief description of why this cashback was paid.
   * @type {string}
   * @memberof CashbackObject
   */
  description: string;
  /**
   * The total amount of cashback paid, represented as a positive value.
   * @type {MoneyObject}
   * @memberof CashbackObject
   */
  amount: MoneyObject;
}
/**
 * Provides information about a category and its ancestry.
 * @export
 * @interface CategoryResource
 */
export interface CategoryResource {
  /**
   * The type of this resource: `categories`
   * @type {string}
   * @memberof CategoryResource
   */
  type: string;
  /**
   * The unique identifier for this category. This is a human-readable but URL-safe value.
   * @type {string}
   * @memberof CategoryResource
   */
  id: string;
  /**
   *
   * @type {CategoryResourceAttributes}
   * @memberof CategoryResource
   */
  attributes: CategoryResourceAttributes;
  /**
   *
   * @type {CategoryResourceRelationships}
   * @memberof CategoryResource
   */
  relationships: CategoryResourceRelationships;
  /**
   *
   * @type {AccountResourceLinks}
   * @memberof CategoryResource
   */
  links?: AccountResourceLinks;
}
/**
 *
 * @export
 * @interface CategoryResourceAttributes
 */
export interface CategoryResourceAttributes {
  /**
   * The name of this category as seen in the Up application.
   * @type {string}
   * @memberof CategoryResourceAttributes
   */
  name: string;
}
/**
 *
 * @export
 * @interface CategoryResourceRelationships
 */
export interface CategoryResourceRelationships {
  /**
   *
   * @type {CategoryResourceRelationshipsParent}
   * @memberof CategoryResourceRelationships
   */
  parent: CategoryResourceRelationshipsParent;
  /**
   *
   * @type {CategoryResourceRelationshipsChildren}
   * @memberof CategoryResourceRelationships
   */
  children: CategoryResourceRelationshipsChildren;
}
/**
 *
 * @export
 * @interface CategoryResourceRelationshipsChildren
 */
export interface CategoryResourceRelationshipsChildren {
  /**
   *
   * @type {Array<CategoryResourceRelationshipsChildrenData>}
   * @memberof CategoryResourceRelationshipsChildren
   */
  data: Array<CategoryResourceRelationshipsChildrenData>;
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof CategoryResourceRelationshipsChildren
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface CategoryResourceRelationshipsChildrenData
 */
export interface CategoryResourceRelationshipsChildrenData {
  /**
   * The type of this resource: `categories`
   * @type {string}
   * @memberof CategoryResourceRelationshipsChildrenData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof CategoryResourceRelationshipsChildrenData
   */
  id: string;
}
/**
 *
 * @export
 * @interface CategoryResourceRelationshipsParent
 */
export interface CategoryResourceRelationshipsParent {
  /**
   *
   * @type {CategoryResourceRelationshipsParentData}
   * @memberof CategoryResourceRelationshipsParent
   */
  data: CategoryResourceRelationshipsParentData | null;
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof CategoryResourceRelationshipsParent
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface CategoryResourceRelationshipsParentData
 */
export interface CategoryResourceRelationshipsParentData {
  /**
   * The type of this resource: `categories`
   * @type {string}
   * @memberof CategoryResourceRelationshipsParentData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof CategoryResourceRelationshipsParentData
   */
  id: string;
}
/**
 * Request to create a new webhook. This currently only requires a `url` attribute.
 * @export
 * @interface CreateWebhookRequest
 */
export interface CreateWebhookRequest {
  /**
   * The webhook resource to create.
   * @type {WebhookInputResource}
   * @memberof CreateWebhookRequest
   */
  data: WebhookInputResource;
}
/**
 * Successful response after creating a webhook.
 * @export
 * @interface CreateWebhookResponse
 */
export interface CreateWebhookResponse {
  /**
   * The webhook that was created.
   * @type {WebhookResource}
   * @memberof CreateWebhookResponse
   */
  data: WebhookResource;
}
/**
 * Provides information about an error processing a request.
 * @export
 * @interface ErrorObject
 */
export interface ErrorObject {
  /**
   * The HTTP status code associated with this error. This can also be obtained from the response headers. The status indicates the broad type of error according to HTTP semantics.
   * @type {string}
   * @memberof ErrorObject
   */
  status: string;
  /**
   * A short description of this error. This should be stable across multiple occurrences of this type of error and typically expands on the reason for the status code.
   * @type {string}
   * @memberof ErrorObject
   */
  title: string;
  /**
   * A detailed description of this error. This should be considered unique to individual occurrences of an error and subject to change. It is useful for debugging purposes.
   * @type {string}
   * @memberof ErrorObject
   */
  detail: string;
  /**
   *
   * @type {ErrorObjectSource}
   * @memberof ErrorObject
   */
  source?: ErrorObjectSource;
}
/**
 * If applicable, location in the request that this error relates to. This may be a parameter in the query string, or a an attribute in the request body.
 * @export
 * @interface ErrorObjectSource
 */
export interface ErrorObjectSource {
  /**
   * If this error relates to a query parameter, the name of the parameter.
   * @type {string}
   * @memberof ErrorObjectSource
   */
  parameter?: string;
  /**
   * If this error relates to an attribute in the request body, a rfc-6901 JSON pointer to the attribute.
   * @type {string}
   * @memberof ErrorObjectSource
   */
  pointer?: string;
}
/**
 * Generic error response that returns one or more errors.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   * The list of errors returned in this response.
   * @type {Array<ErrorObject>}
   * @memberof ErrorResponse
   */
  errors: Array<ErrorObject>;
}
/**
 * Successful response to get a single account.
 * @export
 * @interface GetAccountResponse
 */
export interface GetAccountResponse {
  /**
   * The account returned in this response.
   * @type {AccountResource}
   * @memberof GetAccountResponse
   */
  data: AccountResource;
}
/**
 * Successful response to get a single category and its ancestry.
 * @export
 * @interface GetCategoryResponse
 */
export interface GetCategoryResponse {
  /**
   * The category returned in this response.
   * @type {CategoryResource}
   * @memberof GetCategoryResponse
   */
  data: CategoryResource;
}
/**
 * Successful response to get a single transaction.
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
  /**
   * The transaction returned in this response.
   * @type {TransactionResource}
   * @memberof GetTransactionResponse
   */
  data: TransactionResource;
}
/**
 * Successful response to get a single webhook.
 * @export
 * @interface GetWebhookResponse
 */
export interface GetWebhookResponse {
  /**
   * The webhook returned in this response.
   * @type {WebhookResource}
   * @memberof GetWebhookResponse
   */
  data: WebhookResource;
}
/**
 * Provides information about the amount at which a transaction was in the `HELD` status.
 * @export
 * @interface HoldInfoObject
 */
export interface HoldInfoObject {
  /**
   * The amount of this transaction while in the `HELD` status, in Australian dollars.
   * @type {MoneyObject}
   * @memberof HoldInfoObject
   */
  amount: MoneyObject;
  /**
   * The foreign currency amount of this transaction while in the `HELD` status. This field will be `null` for domestic transactions. The amount was converted to the AUD amount reflected in the `amount` field.
   * @type {MoneyObject}
   * @memberof HoldInfoObject
   */
  foreignAmount: MoneyObject | null;
}
/**
 * Successful response to get all accounts. This returns a paginated list of accounts, which can be scrolled by following the `prev` and `next` links if present.
 * @export
 * @interface ListAccountsResponse
 */
export interface ListAccountsResponse {
  /**
   * The list of accounts returned in this response.
   * @type {Array<AccountResource>}
   * @memberof ListAccountsResponse
   */
  data: Array<AccountResource>;
  /**
   *
   * @type {ListAccountsResponseLinks}
   * @memberof ListAccountsResponse
   */
  links: ListAccountsResponseLinks;
}
/**
 *
 * @export
 * @interface ListAccountsResponseLinks
 */
export interface ListAccountsResponseLinks {
  /**
   * The link to the previous page in the results. If this value is `null` there is no previous page.
   * @type {string}
   * @memberof ListAccountsResponseLinks
   */
  prev: string | null;
  /**
   * The link to the next page in the results. If this value is `null` there is no next page.
   * @type {string}
   * @memberof ListAccountsResponseLinks
   */
  next: string | null;
}
/**
 * Successful response to get all categories and their ancestry. The returned list is not paginated.
 * @export
 * @interface ListCategoriesResponse
 */
export interface ListCategoriesResponse {
  /**
   * The list of categories returned in this response.
   * @type {Array<CategoryResource>}
   * @memberof ListCategoriesResponse
   */
  data: Array<CategoryResource>;
}
/**
 * Successful response to get all tags. This returns a paginated list of tags, which can be scrolled by following the `prev` and `next` links if present.
 * @export
 * @interface ListTagsResponse
 */
export interface ListTagsResponse {
  /**
   * The list of tags returned in this response.
   * @type {Array<TagResource>}
   * @memberof ListTagsResponse
   */
  data: Array<TagResource>;
  /**
   *
   * @type {ListAccountsResponseLinks}
   * @memberof ListTagsResponse
   */
  links: ListAccountsResponseLinks;
}
/**
 * Successful response to get all transactions. This returns a paginated list of transactions, which can be scrolled by following the `prev` and `next` links if present.
 * @export
 * @interface ListTransactionsResponse
 */
export interface ListTransactionsResponse {
  /**
   * The list of transactions returned in this response.
   * @type {Array<TransactionResource>}
   * @memberof ListTransactionsResponse
   */
  data: Array<TransactionResource>;
  /**
   *
   * @type {ListAccountsResponseLinks}
   * @memberof ListTransactionsResponse
   */
  links: ListAccountsResponseLinks;
}
/**
 * Successful response to get all delivery logs for a webhook. This returns a paginated list of delivery logs, which can be scrolled by following the `next` and `prev` links if present.
 * @export
 * @interface ListWebhookDeliveryLogsResponse
 */
export interface ListWebhookDeliveryLogsResponse {
  /**
   * The list of delivery logs returned in this response.
   * @type {Array<WebhookDeliveryLogResource>}
   * @memberof ListWebhookDeliveryLogsResponse
   */
  data: Array<WebhookDeliveryLogResource>;
  /**
   *
   * @type {ListAccountsResponseLinks}
   * @memberof ListWebhookDeliveryLogsResponse
   */
  links: ListAccountsResponseLinks;
}
/**
 * Successful response to get all webhooks. This returns a paginated list of webhooks, which can be scrolled by following the `prev` and `next` links if present.
 * @export
 * @interface ListWebhooksResponse
 */
export interface ListWebhooksResponse {
  /**
   * The list of webhooks returned in this response.
   * @type {Array<WebhookResource>}
   * @memberof ListWebhooksResponse
   */
  data: Array<WebhookResource>;
  /**
   *
   * @type {ListAccountsResponseLinks}
   * @memberof ListWebhooksResponse
   */
  links: ListAccountsResponseLinks;
}
/**
 * Provides information about a value of money.
 * @export
 * @interface MoneyObject
 */
export interface MoneyObject {
  /**
   * The ISO 4217 currency code.
   * @type {string}
   * @memberof MoneyObject
   */
  currencyCode: string;
  /**
   * The amount of money, formatted as a string in the relevant currency. For example, for an Australian dollar value of $10.56, this field will be `\"10.56\"`. The currency symbol is not included in the string.
   * @type {string}
   * @memberof MoneyObject
   */
  value: string;
  /**
   * The amount of money in the smallest denomination for the currency, as a 64-bit integer.  For example, for an Australian dollar value of $10.56, this field will be `1056`.
   * @type {number}
   * @memberof MoneyObject
   */
  valueInBaseUnits: number;
}
/**
 * Basic ping response to verify authentication.
 * @export
 * @interface PingResponse
 */
export interface PingResponse {
  /**
   *
   * @type {PingResponseMeta}
   * @memberof PingResponse
   */
  meta: PingResponseMeta;
}
/**
 *
 * @export
 * @interface PingResponseMeta
 */
export interface PingResponseMeta {
  /**
   * The unique identifier of the authenticated customer.
   * @type {string}
   * @memberof PingResponseMeta
   */
  id: string;
  /**
   * A cute emoji that represents the response status.
   * @type {string}
   * @memberof PingResponseMeta
   */
  statusEmoji: string;
}
/**
 * Provides information about how a Round Up was applied, such as whether or not a boost was included in the Round Up.
 * @export
 * @interface RoundUpObject
 */
export interface RoundUpObject {
  /**
   * The total amount of this Round Up, including any boosts, represented as a negative value.
   * @type {MoneyObject}
   * @memberof RoundUpObject
   */
  amount: MoneyObject;
  /**
   * The portion of the Round Up `amount` owing to boosted Round Ups, represented as a negative value. If no boost was added to the Round Up this field will be `null`.
   * @type {MoneyObject}
   * @memberof RoundUpObject
   */
  boostPortion: MoneyObject | null;
}
/**
 * Uniquely identifies a single tag in the API.
 * @export
 * @interface TagInputResourceIdentifier
 */
export interface TagInputResourceIdentifier {
  /**
   * The type of this resource: `tags`
   * @type {string}
   * @memberof TagInputResourceIdentifier
   */
  type: string;
  /**
   * The label of the tag, which also acts as the tag’s unique identifier.
   * @type {string}
   * @memberof TagInputResourceIdentifier
   */
  id: string;
}
/**
 * Provides information about a tag.
 * @export
 * @interface TagResource
 */
export interface TagResource {
  /**
   * The type of this resource: `tags`
   * @type {string}
   * @memberof TagResource
   */
  type: string;
  /**
   * The label of the tag, which also acts as the tag’s unique identifier.
   * @type {string}
   * @memberof TagResource
   */
  id: string;
  /**
   *
   * @type {AccountResourceRelationships}
   * @memberof TagResource
   */
  relationships: AccountResourceRelationships;
}
/**
 *
 * @export
 * @interface TransactionResource
 */
export interface TransactionResource {
  /**
   * The type of this resource: `transactions`
   * @type {string}
   * @memberof TransactionResource
   */
  type: string;
  /**
   * The unique identifier for this transaction.
   * @type {string}
   * @memberof TransactionResource
   */
  id: string;
  /**
   *
   * @type {TransactionResourceAttributes}
   * @memberof TransactionResource
   */
  attributes: TransactionResourceAttributes;
  /**
   *
   * @type {TransactionResourceRelationships}
   * @memberof TransactionResource
   */
  relationships: TransactionResourceRelationships;
  /**
   *
   * @type {AccountResourceLinks}
   * @memberof TransactionResource
   */
  links?: AccountResourceLinks;
}
/**
 *
 * @export
 * @interface TransactionResourceAttributes
 */
export interface TransactionResourceAttributes {
  /**
   * The current processing status of this transaction, according to whether or not this transaction has settled or is still held.
   * @type {TransactionStatusEnum}
   * @memberof TransactionResourceAttributes
   */
  status: TransactionStatusEnum;
  /**
   * The original, unprocessed text of the transaction. This is often not a perfect indicator of the actual merchant, but it is useful for reconciliation purposes in some cases.
   * @type {string}
   * @memberof TransactionResourceAttributes
   */
  rawText: string | null;
  /**
   * A short description for this transaction. Usually the merchant name for purchases.
   * @type {string}
   * @memberof TransactionResourceAttributes
   */
  description: string;
  /**
   * Attached message for this transaction, such as a payment message, or a transfer note.
   * @type {string}
   * @memberof TransactionResourceAttributes
   */
  message: string | null;
  /**
   * If this transaction is currently in the `HELD` status, or was ever in the `HELD` status, the `amount` and `foreignAmount` of the transaction while `HELD`.
   * @type {HoldInfoObject}
   * @memberof TransactionResourceAttributes
   */
  holdInfo: HoldInfoObject | null;
  /**
   * Details of how this transaction was rounded-up. If no Round Up was applied this field will be `null`.
   * @type {RoundUpObject}
   * @memberof TransactionResourceAttributes
   */
  roundUp: RoundUpObject | null;
  /**
   * If all or part of this transaction was instantly reimbursed in the form of cashback, details of the reimbursement.
   * @type {CashbackObject}
   * @memberof TransactionResourceAttributes
   */
  cashback: CashbackObject | null;
  /**
   * The amount of this transaction in Australian dollars. For transactions that were once `HELD` but are now `SETTLED`, refer to the `holdInfo` field for the original `amount` the transaction was `HELD` at.
   * @type {MoneyObject}
   * @memberof TransactionResourceAttributes
   */
  amount: MoneyObject;
  /**
   * The foreign currency amount of this transaction. This field will be `null` for domestic transactions. The amount was converted to the AUD amount reflected in the `amount` of this transaction. Refer to the `holdInfo` field for the original `foreignAmount` the transaction was `HELD` at.
   * @type {MoneyObject}
   * @memberof TransactionResourceAttributes
   */
  foreignAmount: MoneyObject | null;
  /**
   * The date-time at which this transaction settled. This field will be `null` for transactions that are currently in the `HELD` status.
   * @type {string}
   * @memberof TransactionResourceAttributes
   */
  settledAt: string | null;
  /**
   * The date-time at which this transaction was first encountered.
   * @type {string}
   * @memberof TransactionResourceAttributes
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationships
 */
export interface TransactionResourceRelationships {
  /**
   *
   * @type {TransactionResourceRelationshipsAccount}
   * @memberof TransactionResourceRelationships
   */
  account: TransactionResourceRelationshipsAccount;
  /**
   *
   * @type {CategoryResourceRelationshipsParent}
   * @memberof TransactionResourceRelationships
   */
  category: CategoryResourceRelationshipsParent;
  /**
   *
   * @type {CategoryResourceRelationshipsParent}
   * @memberof TransactionResourceRelationships
   */
  parentCategory: CategoryResourceRelationshipsParent;
  /**
   *
   * @type {TransactionResourceRelationshipsTags}
   * @memberof TransactionResourceRelationships
   */
  tags: TransactionResourceRelationshipsTags;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationshipsAccount
 */
export interface TransactionResourceRelationshipsAccount {
  /**
   *
   * @type {TransactionResourceRelationshipsAccountData}
   * @memberof TransactionResourceRelationshipsAccount
   */
  data: TransactionResourceRelationshipsAccountData;
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof TransactionResourceRelationshipsAccount
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationshipsAccountData
 */
export interface TransactionResourceRelationshipsAccountData {
  /**
   * The type of this resource: `accounts`
   * @type {string}
   * @memberof TransactionResourceRelationshipsAccountData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof TransactionResourceRelationshipsAccountData
   */
  id: string;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationshipsTags
 */
export interface TransactionResourceRelationshipsTags {
  /**
   *
   * @type {Array<TransactionResourceRelationshipsTagsData>}
   * @memberof TransactionResourceRelationshipsTags
   */
  data: Array<TransactionResourceRelationshipsTagsData>;
  /**
   *
   * @type {TransactionResourceRelationshipsTagsLinks}
   * @memberof TransactionResourceRelationshipsTags
   */
  links?: TransactionResourceRelationshipsTagsLinks;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationshipsTagsData
 */
export interface TransactionResourceRelationshipsTagsData {
  /**
   * The type of this resource: `tags`
   * @type {string}
   * @memberof TransactionResourceRelationshipsTagsData
   */
  type: string;
  /**
   * The label of the tag, which also acts as the tag’s unique identifier.
   * @type {string}
   * @memberof TransactionResourceRelationshipsTagsData
   */
  id: string;
}
/**
 *
 * @export
 * @interface TransactionResourceRelationshipsTagsLinks
 */
export interface TransactionResourceRelationshipsTagsLinks {
  /**
   * The link to retrieve or modify linkage between this resources and the related resource(s) in this relationship.
   * @type {string}
   * @memberof TransactionResourceRelationshipsTagsLinks
   */
  self: string;
}
/**
 * Specifies which stage of processing a transaction is currently at. Currently returned values are `HELD` and `SETTLED`. When a transaction is held, its account’s `availableBalance` is affected. When a transaction is settled, its account’s `currentBalance` is affected.
 * @export
 * @enum {string}
 */

export enum TransactionStatusEnum {
  Held = "HELD",
  Settled = "SETTLED",
}

/**
 * Request to add or remove tags associated with a transaction.
 * @export
 * @interface UpdateTransactionTagsRequest
 */
export interface UpdateTransactionTagsRequest {
  /**
   * The tags to add to or remove from the transaction.
   * @type {Array<TagInputResourceIdentifier>}
   * @memberof UpdateTransactionTagsRequest
   */
  data: Array<TagInputResourceIdentifier>;
}
/**
 * Provides historical webhook event delivery information for analysis and debugging purposes.
 * @export
 * @interface WebhookDeliveryLogResource
 */
export interface WebhookDeliveryLogResource {
  /**
   * The type of this resource: `webhook-delivery-logs`
   * @type {string}
   * @memberof WebhookDeliveryLogResource
   */
  type: string;
  /**
   * The unique identifier for this log entry.
   * @type {string}
   * @memberof WebhookDeliveryLogResource
   */
  id: string;
  /**
   *
   * @type {WebhookDeliveryLogResourceAttributes}
   * @memberof WebhookDeliveryLogResource
   */
  attributes: WebhookDeliveryLogResourceAttributes;
  /**
   *
   * @type {WebhookDeliveryLogResourceRelationships}
   * @memberof WebhookDeliveryLogResource
   */
  relationships: WebhookDeliveryLogResourceRelationships;
}
/**
 *
 * @export
 * @interface WebhookDeliveryLogResourceAttributes
 */
export interface WebhookDeliveryLogResourceAttributes {
  /**
   *
   * @type {WebhookDeliveryLogResourceAttributesRequest}
   * @memberof WebhookDeliveryLogResourceAttributes
   */
  request: WebhookDeliveryLogResourceAttributesRequest;
  /**
   *
   * @type {WebhookDeliveryLogResourceAttributesResponse}
   * @memberof WebhookDeliveryLogResourceAttributes
   */
  response: WebhookDeliveryLogResourceAttributesResponse | null;
  /**
   * The success or failure status of this delivery attempt.
   * @type {WebhookDeliveryStatusEnum}
   * @memberof WebhookDeliveryLogResourceAttributes
   */
  deliveryStatus: WebhookDeliveryStatusEnum;
  /**
   * The date-time at which this log entry was created.
   * @type {string}
   * @memberof WebhookDeliveryLogResourceAttributes
   */
  createdAt: string;
}
/**
 * Information about the request that was sent to the webhook URL.
 * @export
 * @interface WebhookDeliveryLogResourceAttributesRequest
 */
export interface WebhookDeliveryLogResourceAttributesRequest {
  /**
   * The payload that was sent in the request body.
   * @type {string}
   * @memberof WebhookDeliveryLogResourceAttributesRequest
   */
  body: string;
}
/**
 * Information about the response that was received from the webhook URL.
 * @export
 * @interface WebhookDeliveryLogResourceAttributesResponse
 */
export interface WebhookDeliveryLogResourceAttributesResponse {
  /**
   * The HTTP status code received in the response.
   * @type {number}
   * @memberof WebhookDeliveryLogResourceAttributesResponse
   */
  statusCode: number;
  /**
   * The payload that was received in the response body.
   * @type {string}
   * @memberof WebhookDeliveryLogResourceAttributesResponse
   */
  body: string;
}
/**
 *
 * @export
 * @interface WebhookDeliveryLogResourceRelationships
 */
export interface WebhookDeliveryLogResourceRelationships {
  /**
   *
   * @type {WebhookDeliveryLogResourceRelationshipsWebhookEvent}
   * @memberof WebhookDeliveryLogResourceRelationships
   */
  webhookEvent: WebhookDeliveryLogResourceRelationshipsWebhookEvent;
}
/**
 *
 * @export
 * @interface WebhookDeliveryLogResourceRelationshipsWebhookEvent
 */
export interface WebhookDeliveryLogResourceRelationshipsWebhookEvent {
  /**
   *
   * @type {WebhookDeliveryLogResourceRelationshipsWebhookEventData}
   * @memberof WebhookDeliveryLogResourceRelationshipsWebhookEvent
   */
  data: WebhookDeliveryLogResourceRelationshipsWebhookEventData;
}
/**
 *
 * @export
 * @interface WebhookDeliveryLogResourceRelationshipsWebhookEventData
 */
export interface WebhookDeliveryLogResourceRelationshipsWebhookEventData {
  /**
   * The type of this resource: `webhook-events`
   * @type {string}
   * @memberof WebhookDeliveryLogResourceRelationshipsWebhookEventData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof WebhookDeliveryLogResourceRelationshipsWebhookEventData
   */
  id: string;
}
/**
 * Specifies the nature of the success or failure of a webhook delivery attempt to the subscribed webhook URL. The currently returned values are described below:  - **`DELIVERED`**: The event was delivered to the webhook URL   successfully and a `200` response was received. - **`UNDELIVERABLE`**: The webhook URL was not reachable, or timed out. - **`BAD_RESPONSE_CODE`**: The event was delivered to the webhook URL   but a non-`200` response was received.
 * @export
 * @enum {string}
 */

export enum WebhookDeliveryStatusEnum {
  Delivered = "DELIVERED",
  Undeliverable = "UNDELIVERABLE",
  BadResponseCode = "BAD_RESPONSE_CODE",
}

/**
 * Asynchronous callback request used for webhook event delivery.
 * @export
 * @interface WebhookEventCallback
 */
export interface WebhookEventCallback {
  /**
   * The webhook event data sent to the subscribed webhook.
   * @type {WebhookEventResource}
   * @memberof WebhookEventCallback
   */
  data: WebhookEventResource;
}
/**
 * Provides the event data used in asynchronous webhook event callbacks to subscribed endpoints. Webhooks events have defined `eventType`s and may optionally relate to other resources within the Up API.
 * @export
 * @interface WebhookEventResource
 */
export interface WebhookEventResource {
  /**
   * The type of this resource: `webhook-events`
   * @type {string}
   * @memberof WebhookEventResource
   */
  type: string;
  /**
   * The unique identifier for this event. This will remain constant across delivery retries.
   * @type {string}
   * @memberof WebhookEventResource
   */
  id: string;
  /**
   *
   * @type {WebhookEventResourceAttributes}
   * @memberof WebhookEventResource
   */
  attributes: WebhookEventResourceAttributes;
  /**
   *
   * @type {WebhookEventResourceRelationships}
   * @memberof WebhookEventResource
   */
  relationships: WebhookEventResourceRelationships;
}
/**
 *
 * @export
 * @interface WebhookEventResourceAttributes
 */
export interface WebhookEventResourceAttributes {
  /**
   * The type of this event. This can be used to determine what action to take in response to the event.
   * @type {WebhookEventTypeEnum}
   * @memberof WebhookEventResourceAttributes
   */
  eventType: WebhookEventTypeEnum;
  /**
   * The date-time at which this event was generated.
   * @type {string}
   * @memberof WebhookEventResourceAttributes
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface WebhookEventResourceRelationships
 */
export interface WebhookEventResourceRelationships {
  /**
   *
   * @type {WebhookEventResourceRelationshipsWebhook}
   * @memberof WebhookEventResourceRelationships
   */
  webhook: WebhookEventResourceRelationshipsWebhook;
  /**
   *
   * @type {WebhookEventResourceRelationshipsTransaction}
   * @memberof WebhookEventResourceRelationships
   */
  transaction?: WebhookEventResourceRelationshipsTransaction;
}
/**
 *
 * @export
 * @interface WebhookEventResourceRelationshipsTransaction
 */
export interface WebhookEventResourceRelationshipsTransaction {
  /**
   *
   * @type {WebhookEventResourceRelationshipsTransactionData}
   * @memberof WebhookEventResourceRelationshipsTransaction
   */
  data: WebhookEventResourceRelationshipsTransactionData;
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof WebhookEventResourceRelationshipsTransaction
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface WebhookEventResourceRelationshipsTransactionData
 */
export interface WebhookEventResourceRelationshipsTransactionData {
  /**
   * The type of this resource: `transactions`
   * @type {string}
   * @memberof WebhookEventResourceRelationshipsTransactionData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof WebhookEventResourceRelationshipsTransactionData
   */
  id: string;
}
/**
 *
 * @export
 * @interface WebhookEventResourceRelationshipsWebhook
 */
export interface WebhookEventResourceRelationshipsWebhook {
  /**
   *
   * @type {WebhookEventResourceRelationshipsWebhookData}
   * @memberof WebhookEventResourceRelationshipsWebhook
   */
  data: WebhookEventResourceRelationshipsWebhookData;
  /**
   *
   * @type {AccountResourceRelationshipsTransactionsLinks}
   * @memberof WebhookEventResourceRelationshipsWebhook
   */
  links?: AccountResourceRelationshipsTransactionsLinks;
}
/**
 *
 * @export
 * @interface WebhookEventResourceRelationshipsWebhookData
 */
export interface WebhookEventResourceRelationshipsWebhookData {
  /**
   * The type of this resource: `webhooks`
   * @type {string}
   * @memberof WebhookEventResourceRelationshipsWebhookData
   */
  type: string;
  /**
   * The unique identifier of the resource within its type.
   * @type {string}
   * @memberof WebhookEventResourceRelationshipsWebhookData
   */
  id: string;
}
/**
 * Specifies the type of a webhook event. This can be used to determine what action to take in response to the event, such as which relationships to expect.
 * @export
 * @enum {string}
 */

export enum WebhookEventTypeEnum {
  TransactionCreated = "TRANSACTION_CREATED",
  TransactionSettled = "TRANSACTION_SETTLED",
  TransactionDeleted = "TRANSACTION_DELETED",
  Ping = "PING",
}

/**
 * Represents a webhook specified as request input.
 * @export
 * @interface WebhookInputResource
 */
export interface WebhookInputResource {
  /**
   *
   * @type {WebhookInputResourceAttributes}
   * @memberof WebhookInputResource
   */
  attributes: WebhookInputResourceAttributes;
}
/**
 *
 * @export
 * @interface WebhookInputResourceAttributes
 */
export interface WebhookInputResourceAttributes {
  /**
   * The URL that this webhook should post events to. This must be a valid HTTP or HTTPS URL that does not exceed 300 characters in length.
   * @type {string}
   * @memberof WebhookInputResourceAttributes
   */
  url: string;
  /**
   * An optional description for this webhook, up to 64 characters in length.
   * @type {string}
   * @memberof WebhookInputResourceAttributes
   */
  description?: string | null;
}
/**
 * Provides information about a webhook.
 * @export
 * @interface WebhookResource
 */
export interface WebhookResource {
  /**
   * The type of this resource: `webhooks`
   * @type {string}
   * @memberof WebhookResource
   */
  type: string;
  /**
   * The unique identifier for this webhook.
   * @type {string}
   * @memberof WebhookResource
   */
  id: string;
  /**
   *
   * @type {WebhookResourceAttributes}
   * @memberof WebhookResource
   */
  attributes: WebhookResourceAttributes;
  /**
   *
   * @type {WebhookResourceRelationships}
   * @memberof WebhookResource
   */
  relationships: WebhookResourceRelationships;
  /**
   *
   * @type {AccountResourceLinks}
   * @memberof WebhookResource
   */
  links?: AccountResourceLinks;
}
/**
 *
 * @export
 * @interface WebhookResourceAttributes
 */
export interface WebhookResourceAttributes {
  /**
   * The URL that this webhook is configured to `POST` events to.
   * @type {string}
   * @memberof WebhookResourceAttributes
   */
  url: string;
  /**
   * An optional description that was provided at the time the webhook was created.
   * @type {string}
   * @memberof WebhookResourceAttributes
   */
  description: string | null;
  /**
   * A shared secret key used to sign all webhook events sent to the configured webhook URL. This field is returned only once, upon the initial creation of the webhook. If lost, create a new webhook and delete this webhook.  The webhook URL receives a request with a `X-Up-Authenticity-Signature` header, which is the SHA-256 HMAC of the entire raw request body signed using this `secretKey`. It is advised to compute and check this signature to verify the authenticity of requests sent to the webhook URL. See [Handling webhook events](#callback_post_webhookURL) for full details.
   * @type {string}
   * @memberof WebhookResourceAttributes
   */
  secretKey?: string;
  /**
   * The date-time at which this webhook was created.
   * @type {string}
   * @memberof WebhookResourceAttributes
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface WebhookResourceRelationships
 */
export interface WebhookResourceRelationships {
  /**
   *
   * @type {AccountResourceRelationshipsTransactions}
   * @memberof WebhookResourceRelationships
   */
  logs: AccountResourceRelationshipsTransactions;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a paginated list of all accounts for the currently authenticated user. The returned list is paginated and can be scrolled by following the `prev` and `next` links where present.
     * @summary List accounts
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet: async (
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a specific account by providing its unique identifier.
     * @summary Retrieve account
     * @param {string} id The unique identifier for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsIdGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("accountsIdGet", "id", id);
      const localVarPath = `/accounts/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a paginated list of all accounts for the currently authenticated user. The returned list is paginated and can be scrolled by following the `prev` and `next` links where present.
     * @summary List accounts
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsGet(
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListAccountsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a specific account by providing its unique identifier.
     * @summary Retrieve account
     * @param {string} id The unique identifier for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsIdGet(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetAccountResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountsIdGet(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Retrieve a paginated list of all accounts for the currently authenticated user. The returned list is paginated and can be scrolled by following the `prev` and `next` links where present.
     * @summary List accounts
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsGet(
      pageSize?: number,
      options?: any
    ): AxiosPromise<ListAccountsResponse> {
      return localVarFp
        .accountsGet(pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a specific account by providing its unique identifier.
     * @summary Retrieve account
     * @param {string} id The unique identifier for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsIdGet(id: string, options?: any): AxiosPromise<GetAccountResponse> {
      return localVarFp
        .accountsIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Retrieve a paginated list of all accounts for the currently authenticated user. The returned list is paginated and can be scrolled by following the `prev` and `next` links where present.
   * @summary List accounts
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsGet(pageSize?: number, options?: any) {
    return AccountsApiFp(this.configuration)
      .accountsGet(pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a specific account by providing its unique identifier.
   * @summary Retrieve account
   * @param {string} id The unique identifier for the account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public accountsIdGet(id: string, options?: any) {
    return AccountsApiFp(this.configuration)
      .accountsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a list of all categories and their ancestry. The returned list is not paginated.
     * @summary List categories
     * @param {string} [filterParent] The unique identifier of a parent category for which to return only its children. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    categoriesGet: async (
      filterParent?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/categories`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (filterParent !== undefined) {
        localVarQueryParameter["filter[parent]"] = filterParent;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a specific category by providing its unique identifier.
     * @summary Retrieve category
     * @param {string} id The unique identifier for the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    categoriesIdGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("categoriesIdGet", "id", id);
      const localVarPath = `/categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CategoriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all categories and their ancestry. The returned list is not paginated.
     * @summary List categories
     * @param {string} [filterParent] The unique identifier of a parent category for which to return only its children. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async categoriesGet(
      filterParent?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListCategoriesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesGet(
        filterParent,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a specific category by providing its unique identifier.
     * @summary Retrieve category
     * @param {string} id The unique identifier for the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async categoriesIdGet(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetCategoryResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesIdGet(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CategoriesApiFp(configuration);
  return {
    /**
     * Retrieve a list of all categories and their ancestry. The returned list is not paginated.
     * @summary List categories
     * @param {string} [filterParent] The unique identifier of a parent category for which to return only its children. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    categoriesGet(
      filterParent?: string,
      options?: any
    ): AxiosPromise<ListCategoriesResponse> {
      return localVarFp
        .categoriesGet(filterParent, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a specific category by providing its unique identifier.
     * @summary Retrieve category
     * @param {string} id The unique identifier for the category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    categoriesIdGet(
      id: string,
      options?: any
    ): AxiosPromise<GetCategoryResponse> {
      return localVarFp
        .categoriesIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
  /**
   * Retrieve a list of all categories and their ancestry. The returned list is not paginated.
   * @summary List categories
   * @param {string} [filterParent] The unique identifier of a parent category for which to return only its children. Providing an invalid category identifier results in a &#x60;404&#x60; response.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public categoriesGet(filterParent?: string, options?: any) {
    return CategoriesApiFp(this.configuration)
      .categoriesGet(filterParent, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a specific category by providing its unique identifier.
   * @summary Retrieve category
   * @param {string} id The unique identifier for the category.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public categoriesIdGet(id: string, options?: any) {
    return CategoriesApiFp(this.configuration)
      .categoriesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a list of all tags currently in use. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered lexicographically. The `transactions` relationship for each tag exposes a link to get the transactions with the given tag.
     * @summary List tags
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsGet: async (
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Disassociates one or more tags from a specific transaction. Tags that are not associated are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Remove tags from transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsTransactionIdRelationshipsTagsDelete: async (
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists(
        "transactionsTransactionIdRelationshipsTagsDelete",
        "transactionId",
        transactionId
      );
      const localVarPath =
        `/transactions/{transactionId}/relationships/tags`.replace(
          `{${"transactionId"}}`,
          encodeURIComponent(String(transactionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateTransactionTagsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Associates one or more tags with a specific transaction. No more than 6 tags may be present on any single transaction. Duplicate tags are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Add tags to transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsTransactionIdRelationshipsTagsPost: async (
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'transactionId' is not null or undefined
      assertParamExists(
        "transactionsTransactionIdRelationshipsTagsPost",
        "transactionId",
        transactionId
      );
      const localVarPath =
        `/transactions/{transactionId}/relationships/tags`.replace(
          `{${"transactionId"}}`,
          encodeURIComponent(String(transactionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateTransactionTagsRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all tags currently in use. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered lexicographically. The `transactions` relationship for each tag exposes a link to get the transactions with the given tag.
     * @summary List tags
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tagsGet(
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTagsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Disassociates one or more tags from a specific transaction. Tags that are not associated are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Remove tags from transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transactionsTransactionIdRelationshipsTagsDelete(
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transactionsTransactionIdRelationshipsTagsDelete(
          transactionId,
          updateTransactionTagsRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Associates one or more tags with a specific transaction. No more than 6 tags may be present on any single transaction. Duplicate tags are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Add tags to transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transactionsTransactionIdRelationshipsTagsPost(
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transactionsTransactionIdRelationshipsTagsPost(
          transactionId,
          updateTransactionTagsRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TagsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all tags currently in use. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered lexicographically. The `transactions` relationship for each tag exposes a link to get the transactions with the given tag.
     * @summary List tags
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tagsGet(pageSize?: number, options?: any): AxiosPromise<ListTagsResponse> {
      return localVarFp
        .tagsGet(pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Disassociates one or more tags from a specific transaction. Tags that are not associated are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Remove tags from transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsTransactionIdRelationshipsTagsDelete(
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .transactionsTransactionIdRelationshipsTagsDelete(
          transactionId,
          updateTransactionTagsRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Associates one or more tags with a specific transaction. No more than 6 tags may be present on any single transaction. Duplicate tags are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
     * @summary Add tags to transaction
     * @param {string} transactionId The unique identifier for the transaction.
     * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsTransactionIdRelationshipsTagsPost(
      transactionId: string,
      updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .transactionsTransactionIdRelationshipsTagsPost(
          transactionId,
          updateTransactionTagsRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
  /**
   * Retrieve a list of all tags currently in use. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered lexicographically. The `transactions` relationship for each tag exposes a link to get the transactions with the given tag.
   * @summary List tags
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public tagsGet(pageSize?: number, options?: any) {
    return TagsApiFp(this.configuration)
      .tagsGet(pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Disassociates one or more tags from a specific transaction. Tags that are not associated are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
   * @summary Remove tags from transaction
   * @param {string} transactionId The unique identifier for the transaction.
   * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public transactionsTransactionIdRelationshipsTagsDelete(
    transactionId: string,
    updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
    options?: any
  ) {
    return TagsApiFp(this.configuration)
      .transactionsTransactionIdRelationshipsTagsDelete(
        transactionId,
        updateTransactionTagsRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Associates one or more tags with a specific transaction. No more than 6 tags may be present on any single transaction. Duplicate tags are silently ignored. An HTTP `204` is returned on success. The associated tags, along with this request URL, are also exposed via the `tags` relationship on the transaction resource returned from `/transactions/{id}`.
   * @summary Add tags to transaction
   * @param {string} transactionId The unique identifier for the transaction.
   * @param {UpdateTransactionTagsRequest} [updateTransactionTagsRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagsApi
   */
  public transactionsTransactionIdRelationshipsTagsPost(
    transactionId: string,
    updateTransactionTagsRequest?: UpdateTransactionTagsRequest,
    options?: any
  ) {
    return TagsApiFp(this.configuration)
      .transactionsTransactionIdRelationshipsTagsPost(
        transactionId,
        updateTransactionTagsRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a list of all transactions for a specific account. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions by account
     * @param {string} accountId The unique identifier for the account.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsAccountIdTransactionsGet: async (
      accountId: string,
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "accountsAccountIdTransactionsGet",
        "accountId",
        accountId
      );
      const localVarPath = `/accounts/{accountId}/transactions`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      if (filterStatus !== undefined) {
        localVarQueryParameter["filter[status]"] = filterStatus;
      }

      if (filterSince !== undefined) {
        localVarQueryParameter["filter[since]"] =
          (filterSince as any) instanceof Date
            ? (filterSince as any).toISOString()
            : filterSince;
      }

      if (filterUntil !== undefined) {
        localVarQueryParameter["filter[until]"] =
          (filterUntil as any) instanceof Date
            ? (filterUntil as any).toISOString()
            : filterUntil;
      }

      if (filterCategory !== undefined) {
        localVarQueryParameter["filter[category]"] = filterCategory;
      }

      if (filterTag !== undefined) {
        localVarQueryParameter["filter[tag]"] = filterTag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a list of all transactions across all accounts for the currently authenticated user. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsGet: async (
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      if (filterStatus !== undefined) {
        localVarQueryParameter["filter[status]"] = filterStatus;
      }

      if (filterSince !== undefined) {
        localVarQueryParameter["filter[since]"] =
          (filterSince as any) instanceof Date
            ? (filterSince as any).toISOString()
            : filterSince;
      }

      if (filterUntil !== undefined) {
        localVarQueryParameter["filter[until]"] =
          (filterUntil as any) instanceof Date
            ? (filterUntil as any).toISOString()
            : filterUntil;
      }

      if (filterCategory !== undefined) {
        localVarQueryParameter["filter[category]"] = filterCategory;
      }

      if (filterTag !== undefined) {
        localVarQueryParameter["filter[tag]"] = filterTag;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a specific transaction by providing its unique identifier.
     * @summary Retrieve transaction
     * @param {string} id The unique identifier for the transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsIdGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("transactionsIdGet", "id", id);
      const localVarPath = `/transactions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TransactionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all transactions for a specific account. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions by account
     * @param {string} accountId The unique identifier for the account.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountsAccountIdTransactionsGet(
      accountId: string,
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTransactionsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.accountsAccountIdTransactionsGet(
          accountId,
          pageSize,
          filterStatus,
          filterSince,
          filterUntil,
          filterCategory,
          filterTag,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a list of all transactions across all accounts for the currently authenticated user. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transactionsGet(
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListTransactionsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.transactionsGet(
        pageSize,
        filterStatus,
        filterSince,
        filterUntil,
        filterCategory,
        filterTag,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a specific transaction by providing its unique identifier.
     * @summary Retrieve transaction
     * @param {string} id The unique identifier for the transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transactionsIdGet(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetTransactionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transactionsIdGet(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TransactionsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all transactions for a specific account. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions by account
     * @param {string} accountId The unique identifier for the account.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountsAccountIdTransactionsGet(
      accountId: string,
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options?: any
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .accountsAccountIdTransactionsGet(
          accountId,
          pageSize,
          filterStatus,
          filterSince,
          filterUntil,
          filterCategory,
          filterTag,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of all transactions across all accounts for the currently authenticated user. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
     * @summary List transactions
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
     * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
     * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
     * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsGet(
      pageSize?: number,
      filterStatus?: TransactionStatusEnum,
      filterSince?: string,
      filterUntil?: string,
      filterCategory?: string,
      filterTag?: string,
      options?: any
    ): AxiosPromise<ListTransactionsResponse> {
      return localVarFp
        .transactionsGet(
          pageSize,
          filterStatus,
          filterSince,
          filterUntil,
          filterCategory,
          filterTag,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a specific transaction by providing its unique identifier.
     * @summary Retrieve transaction
     * @param {string} id The unique identifier for the transaction.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transactionsIdGet(
      id: string,
      options?: any
    ): AxiosPromise<GetTransactionResponse> {
      return localVarFp
        .transactionsIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   * Retrieve a list of all transactions for a specific account. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
   * @summary List transactions by account
   * @param {string} accountId The unique identifier for the account.
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
   * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
   * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
   * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
   * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public accountsAccountIdTransactionsGet(
    accountId: string,
    pageSize?: number,
    filterStatus?: TransactionStatusEnum,
    filterSince?: string,
    filterUntil?: string,
    filterCategory?: string,
    filterTag?: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .accountsAccountIdTransactionsGet(
        accountId,
        pageSize,
        filterStatus,
        filterSince,
        filterUntil,
        filterCategory,
        filterTag,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of all transactions across all accounts for the currently authenticated user. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. To narrow the results to a specific date range pass one or both of `filter[since]` and `filter[until]` in the query string. These filter parameters **should not** be used for pagination. Results are ordered newest first to oldest last.
   * @summary List transactions
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {TransactionStatusEnum} [filterStatus] The transaction status for which to return records. This can be used to filter &#x60;HELD&#x60; transactions from those that are &#x60;SETTLED&#x60;.
   * @param {string} [filterSince] The start date-time from which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
   * @param {string} [filterUntil] The end date-time up to which to return records, formatted according to rfc-3339. Not to be used for pagination purposes.
   * @param {string} [filterCategory] The category identifier for which to filter transactions. Both parent and child categories can be filtered through this parameter. Providing an invalid category identifier results in a &#x60;404&#x60; response.
   * @param {string} [filterTag] A transaction tag to filter for which to return records. If the tag does not exist, zero records are returned and a success response is given.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public transactionsGet(
    pageSize?: number,
    filterStatus?: TransactionStatusEnum,
    filterSince?: string,
    filterUntil?: string,
    filterCategory?: string,
    filterTag?: string,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration)
      .transactionsGet(
        pageSize,
        filterStatus,
        filterSince,
        filterUntil,
        filterCategory,
        filterTag,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a specific transaction by providing its unique identifier.
   * @summary Retrieve transaction
   * @param {string} id The unique identifier for the transaction.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public transactionsIdGet(id: string, options?: any) {
    return TransactionsApiFp(this.configuration)
      .transactionsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UtilityEndpointsApi - axios parameter creator
 * @export
 */
export const UtilityEndpointsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Make a basic ping request to the API. This is useful to verify that authentication is functioning correctly. On authentication success an HTTP `200` status is returned. On failure an HTTP `401` error response is returned.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilPingGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/util/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UtilityEndpointsApi - functional programming interface
 * @export
 */
export const UtilityEndpointsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UtilityEndpointsApiAxiosParamCreator(configuration);
  return {
    /**
     * Make a basic ping request to the API. This is useful to verify that authentication is functioning correctly. On authentication success an HTTP `200` status is returned. On failure an HTTP `401` error response is returned.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async utilPingGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PingResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.utilPingGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UtilityEndpointsApi - factory interface
 * @export
 */
export const UtilityEndpointsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UtilityEndpointsApiFp(configuration);
  return {
    /**
     * Make a basic ping request to the API. This is useful to verify that authentication is functioning correctly. On authentication success an HTTP `200` status is returned. On failure an HTTP `401` error response is returned.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    utilPingGet(options?: any): AxiosPromise<PingResponse> {
      return localVarFp
        .utilPingGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UtilityEndpointsApi - object-oriented interface
 * @export
 * @class UtilityEndpointsApi
 * @extends {BaseAPI}
 */
export class UtilityEndpointsApi extends BaseAPI {
  /**
   * Make a basic ping request to the API. This is useful to verify that authentication is functioning correctly. On authentication success an HTTP `200` status is returned. On failure an HTTP `401` error response is returned.
   * @summary Ping
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UtilityEndpointsApi
   */
  public utilPingGet(options?: any) {
    return UtilityEndpointsApiFp(this.configuration)
      .utilPingGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve a list of configured webhooks. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered oldest first to newest last.
     * @summary List webhooks
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGet: async (
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a specific webhook by providing its unique identifier. Once deleted, webhook events will no longer be sent to the configured URL.
     * @summary Delete webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksIdDelete: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("webhooksIdDelete", "id", id);
      const localVarPath = `/webhooks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a specific webhook by providing its unique identifier.
     * @summary Retrieve webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksIdGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("webhooksIdGet", "id", id);
      const localVarPath = `/webhooks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new webhook with a given URL. The URL will receive webhook events as JSON-encoded `POST` requests. The URL must respond with a HTTP `200` status on success.  There is currently a limit of 10 webhooks at any given time. Once this limit is reached, existing webhooks will need to be deleted before new webhooks can be created.  Event delivery is retried with exponential backoff if the URL is unreachable or it does not respond with a `200` status. The response includes a `secretKey` attribute, which is used to sign requests sent to the webhook URL. It will not be returned from any other endpoints within the Up API. If the `secretKey` is lost, simply create a new webhook with the same URL, capture its `secretKey` and then delete the original webhook. See [Handling webhook events](#callback_post_webhookURL) for details on how to process webhook events.  It is probably a good idea to test the webhook by [sending it a `PING` event](#post_webhooks_webhookId_ping) after creating it.
     * @summary Create webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksPost: async (
      createWebhookRequest?: CreateWebhookRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/webhooks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWebhookRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a list of delivery logs for a webhook by providing its unique identifier. This is useful for analysis and debugging purposes. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered newest first to oldest last. Logs may be automatically purged after a period of time.
     * @summary List webhook logs
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksWebhookIdLogsGet: async (
      webhookId: string,
      pageSize?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("webhooksWebhookIdLogsGet", "webhookId", webhookId);
      const localVarPath = `/webhooks/{webhookId}/logs`.replace(
        `{${"webhookId"}}`,
        encodeURIComponent(String(webhookId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pageSize !== undefined) {
        localVarQueryParameter["page[size]"] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send a `PING` event to a webhook by providing its unique identifier. This is useful for testing and debugging purposes. The event is delivered asynchronously and its data is returned in the response to this request.
     * @summary Ping webhook
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksWebhookIdPingPost: async (
      webhookId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("webhooksWebhookIdPingPost", "webhookId", webhookId);
      const localVarPath = `/webhooks/{webhookId}/ping`.replace(
        `{${"webhookId"}}`,
        encodeURIComponent(String(webhookId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of configured webhooks. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered oldest first to newest last.
     * @summary List webhooks
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksGet(
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListWebhooksResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(
        pageSize,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a specific webhook by providing its unique identifier. Once deleted, webhook events will no longer be sent to the configured URL.
     * @summary Delete webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksIdDelete(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksIdDelete(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a specific webhook by providing its unique identifier.
     * @summary Retrieve webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksIdGet(
      id: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetWebhookResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksIdGet(
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a new webhook with a given URL. The URL will receive webhook events as JSON-encoded `POST` requests. The URL must respond with a HTTP `200` status on success.  There is currently a limit of 10 webhooks at any given time. Once this limit is reached, existing webhooks will need to be deleted before new webhooks can be created.  Event delivery is retried with exponential backoff if the URL is unreachable or it does not respond with a `200` status. The response includes a `secretKey` attribute, which is used to sign requests sent to the webhook URL. It will not be returned from any other endpoints within the Up API. If the `secretKey` is lost, simply create a new webhook with the same URL, capture its `secretKey` and then delete the original webhook. See [Handling webhook events](#callback_post_webhookURL) for details on how to process webhook events.  It is probably a good idea to test the webhook by [sending it a `PING` event](#post_webhooks_webhookId_ping) after creating it.
     * @summary Create webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksPost(
      createWebhookRequest?: CreateWebhookRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateWebhookResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(
        createWebhookRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieve a list of delivery logs for a webhook by providing its unique identifier. This is useful for analysis and debugging purposes. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered newest first to oldest last. Logs may be automatically purged after a period of time.
     * @summary List webhook logs
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksWebhookIdLogsGet(
      webhookId: string,
      pageSize?: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListWebhookDeliveryLogsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksWebhookIdLogsGet(
          webhookId,
          pageSize,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Send a `PING` event to a webhook by providing its unique identifier. This is useful for testing and debugging purposes. The event is delivered asynchronously and its data is returned in the response to this request.
     * @summary Ping webhook
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async webhooksWebhookIdPingPost(
      webhookId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WebhookEventCallback>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.webhooksWebhookIdPingPost(
          webhookId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WebhooksApiFp(configuration);
  return {
    /**
     * Retrieve a list of configured webhooks. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered oldest first to newest last.
     * @summary List webhooks
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksGet(
      pageSize?: number,
      options?: any
    ): AxiosPromise<ListWebhooksResponse> {
      return localVarFp
        .webhooksGet(pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a specific webhook by providing its unique identifier. Once deleted, webhook events will no longer be sent to the configured URL.
     * @summary Delete webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksIdDelete(id: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .webhooksIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a specific webhook by providing its unique identifier.
     * @summary Retrieve webhook
     * @param {string} id The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksIdGet(id: string, options?: any): AxiosPromise<GetWebhookResponse> {
      return localVarFp
        .webhooksIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new webhook with a given URL. The URL will receive webhook events as JSON-encoded `POST` requests. The URL must respond with a HTTP `200` status on success.  There is currently a limit of 10 webhooks at any given time. Once this limit is reached, existing webhooks will need to be deleted before new webhooks can be created.  Event delivery is retried with exponential backoff if the URL is unreachable or it does not respond with a `200` status. The response includes a `secretKey` attribute, which is used to sign requests sent to the webhook URL. It will not be returned from any other endpoints within the Up API. If the `secretKey` is lost, simply create a new webhook with the same URL, capture its `secretKey` and then delete the original webhook. See [Handling webhook events](#callback_post_webhookURL) for details on how to process webhook events.  It is probably a good idea to test the webhook by [sending it a `PING` event](#post_webhooks_webhookId_ping) after creating it.
     * @summary Create webhook
     * @param {CreateWebhookRequest} [createWebhookRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksPost(
      createWebhookRequest?: CreateWebhookRequest,
      options?: any
    ): AxiosPromise<CreateWebhookResponse> {
      return localVarFp
        .webhooksPost(createWebhookRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of delivery logs for a webhook by providing its unique identifier. This is useful for analysis and debugging purposes. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered newest first to oldest last. Logs may be automatically purged after a period of time.
     * @summary List webhook logs
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {number} [pageSize] The number of records to return in each page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksWebhookIdLogsGet(
      webhookId: string,
      pageSize?: number,
      options?: any
    ): AxiosPromise<ListWebhookDeliveryLogsResponse> {
      return localVarFp
        .webhooksWebhookIdLogsGet(webhookId, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send a `PING` event to a webhook by providing its unique identifier. This is useful for testing and debugging purposes. The event is delivered asynchronously and its data is returned in the response to this request.
     * @summary Ping webhook
     * @param {string} webhookId The unique identifier for the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    webhooksWebhookIdPingPost(
      webhookId: string,
      options?: any
    ): AxiosPromise<WebhookEventCallback> {
      return localVarFp
        .webhooksWebhookIdPingPost(webhookId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
  /**
   * Retrieve a list of configured webhooks. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered oldest first to newest last.
   * @summary List webhooks
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksGet(pageSize?: number, options?: any) {
    return WebhooksApiFp(this.configuration)
      .webhooksGet(pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a specific webhook by providing its unique identifier. Once deleted, webhook events will no longer be sent to the configured URL.
   * @summary Delete webhook
   * @param {string} id The unique identifier for the webhook.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksIdDelete(id: string, options?: any) {
    return WebhooksApiFp(this.configuration)
      .webhooksIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a specific webhook by providing its unique identifier.
   * @summary Retrieve webhook
   * @param {string} id The unique identifier for the webhook.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksIdGet(id: string, options?: any) {
    return WebhooksApiFp(this.configuration)
      .webhooksIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new webhook with a given URL. The URL will receive webhook events as JSON-encoded `POST` requests. The URL must respond with a HTTP `200` status on success.  There is currently a limit of 10 webhooks at any given time. Once this limit is reached, existing webhooks will need to be deleted before new webhooks can be created.  Event delivery is retried with exponential backoff if the URL is unreachable or it does not respond with a `200` status. The response includes a `secretKey` attribute, which is used to sign requests sent to the webhook URL. It will not be returned from any other endpoints within the Up API. If the `secretKey` is lost, simply create a new webhook with the same URL, capture its `secretKey` and then delete the original webhook. See [Handling webhook events](#callback_post_webhookURL) for details on how to process webhook events.  It is probably a good idea to test the webhook by [sending it a `PING` event](#post_webhooks_webhookId_ping) after creating it.
   * @summary Create webhook
   * @param {CreateWebhookRequest} [createWebhookRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksPost(
    createWebhookRequest?: CreateWebhookRequest,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .webhooksPost(createWebhookRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of delivery logs for a webhook by providing its unique identifier. This is useful for analysis and debugging purposes. The returned list is [paginated](#pagination) and can be scrolled by following the `next` and `prev` links where present. Results are ordered newest first to oldest last. Logs may be automatically purged after a period of time.
   * @summary List webhook logs
   * @param {string} webhookId The unique identifier for the webhook.
   * @param {number} [pageSize] The number of records to return in each page.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksWebhookIdLogsGet(
    webhookId: string,
    pageSize?: number,
    options?: any
  ) {
    return WebhooksApiFp(this.configuration)
      .webhooksWebhookIdLogsGet(webhookId, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send a `PING` event to a webhook by providing its unique identifier. This is useful for testing and debugging purposes. The event is delivered asynchronously and its data is returned in the response to this request.
   * @summary Ping webhook
   * @param {string} webhookId The unique identifier for the webhook.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebhooksApi
   */
  public webhooksWebhookIdPingPost(webhookId: string, options?: any) {
    return WebhooksApiFp(this.configuration)
      .webhooksWebhookIdPingPost(webhookId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
